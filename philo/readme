

--------------------------------------------------------------------------------------------------------------------------------------

Requirements : 
  1. understand how threads work and its related concepts.
  2. what is the difference between a process and a thread.
  3. understand the philo problem. 
  4. understand the metaphor behind philo problem
      1. what does the philo represent -> thread.
      2. what does the fork represent -> shared resource.
      //
  5. know what and why to use the allowed functions.
  6. come up with the architecture for this problem and the flow of the solution.
  7. begin doing the parts of the architecture.

--------------------------------------------------------------------------------------------------------------------------------------

Design: 
  1. flowchart for the problem;
  2. data flow (optional);

--------------------------------------------------------------------------------------------------------------------------------------

Implementation
  1. Makefile with appropriate file structure:
  Organize your files into source files (philosophers.c), header files (philosophers.h), and a Makefile that compiles everything and runs the program.

  2. Deep dive and tinker with the allowed functions:
  Threads: Use pthread_create to create threads and pthread_join to wait for them to finish.
  Mutexes: Use pthread_mutex_t to define mutexes for shared resources (the forks). Youâ€™ll use pthread_mutex_lock and pthread_mutex_unlock to control access to these resources.
  Sleep and Timeouts: Use usleep to simulate thinking and eating times. You may also use pthread_cond_t to implement timeouts or retries.

  3. Thread and Shared Resource Design:
  Thread Function: Each philosopher is a thread. Each philosopher needs access to two mutexes (forks). The threads will attempt to lock these mutexes in a safe order to avoid deadlock.
  Shared Resources: Each fork is a shared resource protected by a mutex. Only one philosopher can use a fork at a time.

  4. Edge Cases and Scenarios:
  Deadlock: If every philosopher picks up one fork and waits for the other, none can proceed. To avoid this, you could either impose a strict order on which fork to pick up first or use a timeout for retrying.
  Starvation: Some philosophers might be stuck waiting for forks while others eat. This can be addressed by ensuring fair access to resources (e.g., by using a semaphore or limiting the number of philosophers trying to pick up forks at the same time).

  5. Mutexes: Mutexes are key to preventing race conditions and deadlock. They ensure that only one philosopher can use a fork at a time.




